extern crate nom;
use nom::{
  alt,
  map,
  named,
  one_of,
  recognize,
  do_parse,
  many0,
  number::complete
};


type Name = String;

#[derive(Debug,PartialEq)]
enum Expr {
  Float(f32),
  BinOp(Op, Box<Expr>, Box<Expr>),
  Var(Name),
  Call(Name, ExprList),
  Function(Name, ExprList, Box<Expr>),
  Extern(Name, ExprList)
}

#[derive(Debug,PartialEq)]
enum ExprList {
  Cons(Box<Expr>, Box<ExprList>),
  Nil
}

#[derive(Debug,PartialEq)]
enum Op {
  Plus,
  Minus,
  Multiply,
  Divide
}

/*fn op(l: Expr, o: &'static str, r: Expr) -> Expr {
    Op(Box::new(l), o, Box::new(r))
}
fn id(s: &str) -> Expr {
    Id(String::from(s))
}
let op_parser = string("+").or(string("*"))
    .map(|op| {
        let prec = match op {
            "+" => 6,
            "*" => 7,
            _ => unreachable!()
        };
        (op, Assoc { precedence: prec, fixity: Fixity::Left })
    })
    .skip(spaces());
let term = many(letter())
    .map(Id)
    .skip(spaces());
let mut parser = expression_parser(term, op_parser, op);
let result = parser.easy_parse("a + b * c + d");*/

/*fn parse_float(input: &str) -> IResult<&str, Expr> {
  // FIXME: error handling
  let (input, num) = complete::float(input)?;

  Ok((input, Expr::Float(num)))
}*/

named!(common_char<char>, one_of!("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789"));
named!(initial<char>, one_of!("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_"));

named!(
    common_identifier,
    recognize!( do_parse!(initial >> many0!(common_char) >> ()) )
);

/*fn parse_var(input: &str) -> IResult<&str, Expr> {
  let (input, ident) = common_identifier(input.as_bytes())?;

  Ok((input, Expr::Var(ident)))
}*/

named!(parse_expr<Expr>,
  alt!(
        map!(complete::float, |f| Expr::Float(f)) |
        map!(common_identifier, |s| Expr::Var(std::str::from_utf8(&s).unwrap().to_string()))
  )
);

/*fn parse_expr(input: &str) -> IResult<&str, Expr> {
  alt((
    parse_float,
    parse_float,
  ))(input)
}*/


fn main() {
  println!("foo")
}

macro_rules! assert_parsed_fully {
    ($parser:expr, $input:expr, $result:expr) => {
        assert_eq!(
            $parser($input.as_bytes()),
            Ok((&b""[..], $result))
        );
    }
}

#[test]
fn parse_expr_test() {
  assert_parsed_fully!(parse_expr, "1.1", Expr::Float(1.1));
  assert_parsed_fully!(parse_expr, "2.7", Expr::Float(2.7));
  assert_parsed_fully!(parse_expr, "hello", Expr::Var("hello".to_string()));
  //assert_eq!(parse_expr(b"1.1"), Ok((b"", Expr::Float(1.1))));
  //assert_eq!(parse_expr(b"2.7"), Ok((b"", Expr::Float(2.7))));
  //assert_eq!(parse_expr("1.1 + 2.7"), Ok(("", Expr::BinOp(Op::Plus, Expr::Float(1.1), Expr::Float(2.7)))));
}

